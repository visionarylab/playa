<!doctype html>
<html class="no-js" lang="en">

  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <title>The React/Redux architecture / Playa Devblog / Playa</title>
    <meta name="generator" content="waffel">

    <meta name="version" content="e38feff@master">

    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta name="google-site-verification" content="i8NjOC8rJvuvTJANxL3ZU5lemfbFkovx0ZqSCYwg430">



    <meta name="description" content="Many practices flourished in the React ecosystems, addressing from project files hierarchy to where and how store the app state, to componentsâ€¦">

    <meta property="og:site_name" content="Playa">
    <meta property="og:url" content="https://moonwave99.github.io/playa/devblog/2020-02-01/react-redux-architecture">
    <meta property="og:title" content="The React/Redux architecture | Playa">
    <meta property="og:image" content="https://moonwave99.github.io/playa/images/screenshots/playlist.png">

    <meta property="og:type" content="article">
    <meta property="og:description" content="Many practices flourished in the React ecosystems, addressing from project files hierarchy to where and how store the app state, to components styles. Here are my choices in regard.">
    <meta property="article:published_time" content="2020-02-01T01:00:00.000+0100">


    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="https://moonwave99.github.io/playa//">
    <meta name="twitter:creator" content="@moonwavelabs">
    <meta name="twitter:url" content="https://moonwave99.github.io/playa/devblog/2020-02-01/react-redux-architecture">
    <meta name="twitter:title" content="The React/Redux architecture | Playa">
    <meta property="twitter:image:src" content="https://moonwave99.github.io/playa/images/screenshots/playlist.png">

    <meta name="twitter:description" content="Many practices flourished in the React ecosystems, addressing from project files hierarchy to where and how store the app state, to components styles. Here are my choices in regard.">


    <link rel="stylesheet" href="https://moonwave99.github.io/playa/css/app_e38feff2d201a6061c7e2e0ca0ecbccbdd8373e0.css">
  </head>

  <body class="w-100 sans-serif blog-single">

    <section class="navigation">
      <input type="checkbox" class="navigation-toggler" id="navToggler">
      <label for="navToggler" class="navigation-toggler-label tracked ttu">
        <span class="open">Menu</span>
        <span class="close">Close</span>
      </label>
      <nav class="navigation-content w-100 text-right v-mid ph3 ph4-ns avenir bg-yellow">
        <a class="link black underline-hover mr4-ns" href="https://moonwave99.github.io/playa">Home</a>
        <a class="link black underline-hover mr4-ns" href="https://moonwave99.github.io/playa/about">About</a>
        <a class="link black underline-hover mr4-ns b" href="https://moonwave99.github.io/playa/devblog">Devblog</a>
        <a class="link black underline-hover mr4-ns" href="https://github.com/moonwave99/playa" target="_blank">Github</a>
        <a class="link black underline-hover mr4-ns" href="mailto:hello@diegocaponera.com?subject=Playa">Contact</a>
      </nav>
    </section>

    <main class="main w-100">


      <article class="blog-post mw8-ns center ph3 pb5 pv4 pv6-ns">
        <header class="blog-post-header mb5">
          <time class="tracked ttu">February 01, 2020</time>
          <h1 class="f3 f1-ns lh-solid mt4 mb4">The React/Redux architecture</h1>
        </header>
        <section class="blog-post-content">
          <p class="lh-copy">Many practices flourished in the React ecosystems, addressing from project files hierarchy to where and how store the app state, to components styles. Here are my choices in regard.</p>
          <h2 class="mt5">
            <a name="the-code-class-dark-pink-src-code-organisation" class="anchor" href="#the-code-class-dark-pink-src-code-organisation">
              <span class="link blue">#</span>
            </a>
            The <code class="dark-pink">src</code> organisation
          </h2>
          <p class="lh-copy">The folder structure of an application should favour the development process first of all. How often am I accessing a file? Should other people of the team have non frequent access to any part of it? <a class="link blue underline-hover" href="https://medium.com/hackernoon/the-100-correct-way-to-structure-a-react-app-or-why-theres-no-such-thing-3ede534ef1ed" target='_blank'>This article by David Gilbertson
            </a> contains a lot of sound considerations in this direction.</p>
          <p class="lh-copy">Each <strong>component</strong> lives in a folder named as the component itself, among with specs and styles. The hierarchy system is completely arbitr..ahem is mixed: some components are contained inside the parent component, some others live ad the base level because are shared.</p><pre><code class="language-bash">src
  renderer
    components
      AlbumListView
        AlbumListView.tsx
        AlbumListView.test.tsx
        AlbumListView.scss
        AlbumView
          AlbumView.tsx
          AlbumView.test.tsx
          AlbumView.scss</code></pre>
          <p class="lh-copy">There are some <strong>providers</strong> that are <code class="dark-pink">HOC</code> around pure view layers. They take care of data fetching and event handling, to keep UI easy to test:</p><pre><code class="language-typescript">export const PlaylistContainer = (): ReactElement =&gt; {
  const dispatch = useDispatch();
  const { _id } = useParams();

  const {
    playlist,
    albums,
    isLoading
    ...
  } = useSelector((state: ApplicationState) =&gt; getPlaylistById(state, _id));

  useEffect(() =&gt; {
    ...
  }, [playlist.title]);

  function onAlbumContextMenu() { ... }
  function onAlbumDoubleClick() { ... }

  const shouldShowPlaylist = !isLoading &amp;&amp; playlist.albums.length === Object.keys(albums).length;
  if (!shouldShowPlaylist) {
    return null;
  }
    return (
    &lt;CSSTransition
      in={!isLoading}
      timeout={300}
      classNames=&quot;playlist-view&quot;
      unmountOnExit&gt;
      &lt;PlaylistView
        albums={albums}
        playlist={playlist}
        onAlbumContextMenu={onAlbumContextMenu}
        onAlbumDoubleClick={onAlbumDoubleClick}/&gt;
     &lt;/CSSTransition&gt;
    );
};</code></pre>

          <h2 class="mt5">
            <a name="styles" class="anchor" href="#styles">
              <span class="link blue">#</span>
            </a>
            Styles
          </h2>
          <p class="lh-copy">I used no particular library (besides a normaliser). I am very fond of <a class="link blue underline-hover" href="https://en.wikipedia.org/wiki/The_Elements_of_Typographic_Style" target='_blank'>Robert Bringhurst</a> lectures on typography, and grid systems in general. With <code class="dark-pink">rem</code> units and SASS preprocessing, it is easy to use a size scale that keeps everythin <em>in beat</em>.</p>
          <p class="lh-copy">Styles are imported directly from modules via <code class="dark-pink">style-loader</code>:</p><pre><code class="language-javascript">// App.tsx
import React, { FC, ReactElement, useState, useEffect, useRef } from &#39;react&#39;;
...
import &#39;./App.scss&#39;;</code></pre>
          <p class="lh-copy">Why no inline styles? I am just fine with SASS preprocessing / interpolation / mixins.</p>
          <h2 class="mt5">
            <a name="redux" class="anchor" href="#redux">
              <span class="link blue">#</span>
            </a>
            Redux
          </h2>
          <p class="lh-copy">I like Redux because it acts more like a <strong>low level glue</strong>, rather than as a <strong>rigid framework</strong>. It makes you think about the solutions, and gives you freedom of implementation. Such freedom has a price, called a lot of code to write (and to test). There is a lot of boilerplate to be written, mainly because of Typescript definitions, but once the foundation is stable I didn&#39;t have to add much more material: combining existing actions is enough.</p>
          <h3 class="mt5">
            <a name="selectors" class="anchor" href="#selectors">
              <span class="link blue">#</span>
            </a>
            Selectors
          </h3>
          <p class="lh-copy">Selectors are used in <code class="dark-pink">useSelector</code> hooks or inside <code class="dark-pink">(re-)reselect</code> selectors.</p><pre><code class="language-typescript">// /src/renderer/store/modules/album.ts
export const selectors = {
  state: ({ albums }: { albums: AlbumState }): AlbumState =&gt; albums,
  allById: ({ albums }: { albums: AlbumState }): EntityHashMap&lt;Album&gt; =&gt; albums.allById,
  findById: ({ albums }: { albums: AlbumState }, id: Album[&#39;_id&#39;]): Album =&gt; albums.allById[id],
  findByList: ({ albums }: { albums: AlbumState }, ids: Album[&#39;_id&#39;][]): Album[] =&gt; ids.map(id =&gt; albums.allById[id]),
  findByVariousArtists: ({ albums }: { albums: AlbumState }): Album[] =&gt;
    toArray(albums.allById).filter(({ isAlbumFromVA }) =&gt; isAlbumFromVA)
};

// Usage example
import { selectors as albumSelectors } from &#39;../../store/modules/album&#39;;

...

const albums = useSelector((state: ApplicationState) =&gt; {
  return albumSelectors.findByList(state, listOfAlbumIDs)
});</code></pre>
          <p class="lh-copy">Is it worth having them, as opposed to write ad hoc composite selectors every time? As long as they are tested, they cost nothing and they make simple compositions self-explaining.</p>
          <p class="lh-copy">For more complex cases, <code class="dark-pink">reselect</code> does the job:</p><pre><code class="language-typescript">import { createSelector } from &#39;reselect&#39;;

...

export const playerSelector = createSelector(
  selectors.state,
  playlistSelectors.allById,
  albumSelectors.allById,
  trackSelectors.allById,
  waveformSelectors.allById,
  (player, playlists, albums, tracks, waveforms): GetPlayerInfoSelection =&gt; {
    const {
      currentPlaylistId,
      currentAlbumId,
      currentTrackId,
      queue
    } = player;
    return {
      currentPlaylist: playlists[currentPlaylistId],
      currentAlbum: albums[currentAlbumId],
      currentAlbumId,
      currentTrack: tracks[currentTrackId],
      waveform: waveforms[currentTrackId],
      queue: queue.map(x =&gt; albums[x])
    };
  }
);</code></pre>
          <p class="lh-copy">It makes the component smaller:</p><pre><code class="language-typescript">import {
    playerSelector
} from &#39;../../store/modules/player&#39;;

...

const {
  currentPlaylist,
  currentAlbum,
  currentTrack,
  queue,
  waveform
} = useSelector(playerSelector);</code></pre>
          <p class="lh-copy">Bonus: you test the selector in the store context, leaving the UI to its UI things.</p>
          <h3 class="mt5">
            <a name="actions" class="anchor" href="#actions">
              <span class="link blue">#</span>
            </a>
            Actions
          </h3>
          <p class="lh-copy">I use the the standard <code class="dark-pink">redux-thunk</code> as async handler middleware. Here we have an example of <strong>sync</strong> vs <strong>async</strong> action:</p><pre><code class="language-typescript">export const getAlbumListResponse = (results: Album[]): Function =&gt;
  (dispatch: Function): void =&gt; {
    dispatch({
      type: ALBUM_GET_LIST_RESPONSE,
      results
    });
  }

export const getAlbumListRequest = (ids: Album[&#39;_id&#39;][]): Function =&gt;
  async (dispatch: Function): Promise&lt;void&gt; =&gt; {
    dispatch(
      getAlbumListResponse(
        await ipc.invoke(IPC_ALBUM_GET_LIST_REQUEST, ids)
      )
    );
  }</code></pre>
          <p class="lh-copy">In the first case (<code class="dark-pink">getAlbumListResponse</code>), an action of type <code class="dark-pink">ALBUM_GET_LIST_RESPONSE</code> is dispatched (and thus handled by the reducer).</p>
          <p class="lh-copy">In the second (<code class="dark-pink">getAlbumListRequest</code>), we have to wait for the response of the <code class="dark-pink">ipc.invoke</code> call. We could have moved it outside the action, but that would have given responsibility to the caller context (with all chance, a React component).</p>
          <p class="lh-copy">In order to keep everything in our tidy black box, it is enough to mark the function as <code class="dark-pink">async</code> (and to update the return type to <code class="dark-pink">Promise&lt;void&gt;</code>). Now the action is dispatched after <code class="dark-pink">await</code>ing for the results.</p>
          <p class="lh-copy">Pay attention to how the request and response handlers are separated, both in the actions and in the reducer. In this case I&#39;ve chosen <em>not</em> to dispatch a <code class="dark-pink">ALBUM_GET_LIST_REQUEST</code> action, because I am not updating the UI accordingly. Let&#39;s make a more universal example:</p><pre><code class="language-typescript">// action creator
export const getDataRequest = (query: string): Function =&gt;
  async (dispatch: Function): Promise&lt;void&gt; =&gt; {
    dispatch({
      type: GET_DATA_REQUEST,
      query
    });
    try {
      const data = await someService.get(query);
      dispatch({
        type: GET_DATA_RESPONSE,
        data
      });
    } catch(error) {
      dispatch({
        type: GET_DATA_ERROR,
        error
      });      
    }
  }

// reducer
function reducer(state, action) {
  switch (action.type) {
    case GET_DATA_REQUEST:
      return {
        ...state,
        loading: true
      };
    case GET_DATA_RESPONSE:
      return {
        ...state,
        loading: false,
        error: null,
        data: action.data
      };
    case GET_DATA_ERROR:
      return {
        ...state,
        loading: false,
        error: action.error
      };
  } 
);

// compo
function Compo() {
  const { data, loading, error } = useSelector( ... );

  if (loading) {
    return &lt;div&gt;Loading...&lt;/div&gt;;
  }

  if (error) {
    return &lt;div&gt;{ error.message }&lt;/div&gt;;
  }

  // do something with data
  return ...;
}</code></pre>
          <p class="lh-copy">This way, we cover all cases and we split responsibility between actions. The UI knows when to display a spinner or if to display an error message. This is also important because it makes the components independent - an action may be fired from a part of the UI, and the effects may be reflected elsewhere.</p>
          <p class="lh-copy">As an action creator can dispatch multiple actions, we are not tied to dispatch actions of the same store - think about dispatching a common error or UI handler actions.</p>
          <p class="lh-copy"><strong>Note</strong>: in the Playa case, the <code class="dark-pink">getAlbumListResponse</code> wrapper was needed because the list could come from different sources.</p>
          <h2 class="mt5">
            <a name="what-i-would-like-to-improve" class="anchor" href="#what-i-would-like-to-improve">
              <span class="link blue">#</span>
            </a>
            What I would like to improve
          </h2>
          <ul>
            <li>implement centralised error handling;</li>
            <li>wrap <code class="dark-pink">ipc</code>/database communication in an additional layer to improve testability;</li>
            <li>fine grain some selectors to prevent redundant component re-renders.</li>
          </ul>

        </section>
      </article>
      <div class="album-bar relative overflow-hidden w-100 bg-mid-gray"></div>

    </main>
    <footer class="footer w-100 f6 ph3 ph0-ns pv3 pt4-ns pb5-ns bg-dark-gray light-silver">
      <div class="w-80-ns center">
        <p class="bb lh-copy pb4">
          &copy; 2020 made with
          <a href="https://moonwave99.github.io/waffel" target="_blank" class="link light-silver hover-white underline">waffel</a>,
          <a href="https://tachyons.io" target="_blank" class="link light-silver hover-white underline">tachyons</a> and love <br class="dn-ns" />by
          <a href="https://www.diegocaponera.com" target="_blank" class="link light-silver hover-white underline">Diego Caponera</a>.
        </p>
        <div class="lh-copy cf">
          <p class="fl dn di-ns">
            <a href="#top" class="link light-silver hover-white underline">Back to top</a>
          </p>
          <p class="fr-ns fn tc tr-ns">
            <a href="https://github.com/moonwave99/playa" target="_blank" class="link light-silver hover-white underline">Github</a> /
            <a href="https://github.com/moonwave99/playa/issues" target="_blank" class="link light-silver hover-white underline">Issues</a> /
            <a href="https://github.com/moonwave99/playa/releases" target="_blank" class="link light-silver hover-white underline">Releases</a> /
            <a href="https://moonwave99.github.io/playa/terms-of-use" class="link light-silver hover-white underline">Terms of Use</a>
          </p>
        </div>
      </div>
    </footer>


    <script src="https://moonwave99.github.io/playa/js/vendor_e38feff2d201a6061c7e2e0ca0ecbccbdd8373e0.js"></script>
    <script src="https://moonwave99.github.io/playa/js/app_e38feff2d201a6061c7e2e0ca0ecbccbdd8373e0.js"></script>
    <script>
      require('initialize')({
        title: 'Playa',
        basePath: 'https://moonwave99.github.io/playa',
      });
    </script>
    <script>
      (function(b, o, i, l, e, r) {
        b.GoogleAnalyticsObject = l;
        b[l] || (b[l] =
          function() {
            (b[l].q = b[l].q || []).push(arguments)
          });
        b[l].l = +new Date;
        e = o.createElement(i);
        r = o.getElementsByTagName(i)[0];
        e.src = 'https://www.google-analytics.com/analytics.js';
        r.parentNode.insertBefore(e, r)
      }(window, document, 'script', 'ga'));
      ga('create', 'UA-5216615-13', 'auto');
      ga('send', 'pageview');
    </script>
  </body>

</html>